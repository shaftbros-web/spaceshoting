<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>SPACE SHOOTER — v2 (stable, 3-level powerup)</title>
  <style>
    :root{ --bg:#05070d; --fg:#e6edf3; --accent:#60a5fa; --muted:#9ca3af; }
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; background:var(--bg); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", Meiryo, sans-serif; }
    #wrap{ position:fixed; inset:0; display:grid; }
    canvas{ width:100vw; height:100vh; display:block; touch-action:none; background:#0b1020; }
    .hud{ position:fixed; left:10px; right:10px; top:8px; display:flex; justify-content:space-between; gap:10px; pointer-events:none; font-weight:700; text-shadow: 0 2px 6px rgba(0,0,0,.6); z-index:40; }
    .hud span{ background:rgba(0,0,0,.35); padding:6px 10px; border-radius:12px; }
    .btn{ position:fixed; bottom:12px; right:12px; z-index:50; pointer-events:auto; appearance:none; border:none; border-radius:999px; padding:12px 16px; font-weight:700; background:#1f2937; color:#e5e7eb; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="1280" height="720" aria-label="ゲームキャンバス"></canvas>
  </div>
  <div class="hud">
    <span id="score">SCORE 0</span>
    <span id="level">LV 1</span>
    <span id="best">BEST 0</span>
  </div>
  <button id="reset" class="btn">RESET</button>
  <script>
    // ===== 基本 =====
    const $=id=>document.getElementById(id);
    const canvas=$('game');
    const ctx=canvas.getContext('2d',{alpha:false});
    const elScore=$('score'), elLevel=$('level'), elBest=$('best');
    const btnReset=$('reset');

```
const state={w:1280,h:720,dpr:Math.max(1,Math.min(devicePixelRatio||1,2))};
function resize(){ state.w=Math.max(320,Math.floor(innerWidth)); state.h=Math.max(320,Math.floor(innerHeight)); const {dpr}=state; canvas.width=Math.floor(state.w*dpr); canvas.height=Math.floor(state.h*dpr); canvas.style.width=state.w+'px'; canvas.style.height=state.h+'px'; ctx.setTransform(dpr,0,0,dpr,0,0); }
addEventListener('resize',resize); resize();

// ===== 状態 =====
let score=0; const BEST_KEY='space-best'; let best=Number(localStorage.getItem(BEST_KEY)||0); elBest.textContent='BEST '+best;
let level=1; // 1..3
let running=true;

const player={x:state.w/2,y:state.h*0.78,r:16,targetX:null,targetY:null};
/** @type {{x:number,y:number,v?:number,vx?:number,vy?:number}[]} */ let bullets=[];
/** @type {{x:number,y:number,r:number,s:number,phase:number}[]} */ let enemies=[];
/** @type {{x:number,y:number,vx:number,vy:number,life:number,color:string}[]} */ let particles=[];

const rand=(a,b)=>Math.random()*(b-a)+a;

// ===== 入力（ドラッグ＆PCマウス） =====
function worldFromEvent(ev){ const r=canvas.getBoundingClientRect(); const x=(ev.clientX??ev.touches?.[0]?.clientX??0)-r.left; const y=(ev.clientY??ev.touches?.[0]?.clientY??0)-r.top; return {x,y}; }
canvas.addEventListener('pointerdown',ev=>{ ev.preventDefault(); const p=worldFromEvent(ev); player.targetX=p.x; player.targetY=p.y; });
canvas.addEventListener('pointermove',ev=>{ if(player.targetX==null) return; ev.preventDefault(); const p=worldFromEvent(ev); player.targetX=p.x; player.targetY=p.y; });
canvas.addEventListener('pointerup',()=>{ player.targetX=null; player.targetY=null; });
canvas.addEventListener('pointercancel',()=>{ player.targetX=null; player.targetY=null; });

// ===== ショット（上向き=0基準） =====
function shootPattern(){
  const y = player.y-player.r-4; const baseV=-440; const sp=460;
  const shot=(x,a=0)=>{ if(a===0){ bullets.push({x,y,v:baseV}); } else { const dirX=Math.sin(a), dirY=-Math.cos(a); bullets.push({x,y,vx:dirX*sp,vy:dirY*sp}); } };
  if(level===1){ shot(player.x); }
  else if(level===2){ shot(player.x-10); shot(player.x); shot(player.x+10); }
  else { // level 3
    shot(player.x-14); shot(player.x+14); // 横に2本
    for(const a of [-0.22,0,0.22]) shot(player.x,a); // 扇状3本
  }
}

let fireTimer=0;
let spawnTimer=0;

function checkPowerUp(){ const newLevel = Math.min(3, 1 + Math.floor(score/100)); if(newLevel!==level){ level=newLevel; elLevel.textContent='LV '+level; // 演出
    particles.push({x:player.x,y:player.y-20,vx:0,vy:-60,life:0.5,color:'#34d399'});
  }
}

// ===== ループ =====
let prev=performance.now();
function loop(now){
  const dt=Math.min(0.033,(now-prev)/1000); prev=now; const w=state.w,h=state.h;
  // 背景
  ctx.fillStyle='#05070d'; ctx.fillRect(0,0,w,h); let bg=ctx.createLinearGradient(0,0,0,h); bg.addColorStop(0,'#0b1020'); bg.addColorStop(1,'#090d18'); ctx.fillStyle=bg; ctx.fillRect(0,0,w,h);
  for(let i=0;i<40;i++){ const sx=(i*97%w), sy=((i*53+Math.floor(now*0.03))%h); ctx.globalAlpha=0.2+((i%10)/50); ctx.fillStyle='#fff'; ctx.fillRect(sx,sy,2,2);} ctx.globalAlpha=1;

  if(running){
    // 自機
    if(player.targetX!=null){ player.x += (player.targetX-player.x)*Math.min(1,dt*12); player.y += (player.targetY-player.y)*Math.min(1,dt*12); }
    player.x=Math.max(player.r,Math.min(w-player.r,player.x)); player.y=Math.max(player.r,Math.min(h-player.r,player.y));

    // 発射
    fireTimer-=dt; if(fireTimer<=0){ fireTimer=0.18; shootPattern(); }

    // 弾
    for(const b of bullets){ if(b.v!=null){ b.y+=b.v*dt; } else { b.x+=b.vx*dt; b.y+=b.vy*dt; } }
    bullets=bullets.filter(b=> b.y>-40 && b.y<h+40 && b.x>-40 && b.x<w+40);

    // 敵スポーン
    spawnTimer-=dt; if(spawnTimer<=0){ spawnTimer=Math.max(0.25, 0.9 - score*0.0025); const r=rand(14,22); enemies.push({x:rand(r,w-r), y:-r-20, r, s:rand(60,120), phase:rand(0,Math.PI*2)}); }
    // 敵更新
    for(const e of enemies){ e.y+=e.s*dt; e.x+=Math.sin(e.phase+now*0.003)*40*dt; }
    enemies=enemies.filter(e=> e.y-e.r<h+40);

    // 衝突（自弾→敵）
    for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; for(let j=bullets.length-1;j>=0;j--){ const b=bullets[j]; const dx=e.x-b.x, dy=e.y-b.y; if(dx*dx+dy*dy <= (e.r+6)*(e.r+6)){ enemies.splice(i,1); bullets.splice(j,1); score+=20; elScore.textContent='SCORE '+score; checkPowerUp(); particles.push({x:e.x,y:e.y,vx:0,vy:-80,life:0.4,color:'#93c5fd'}); break; } } }

    // パーティクル
    for(const p of particles){ p.x+=p.vx*dt; p.y+=p.vy*dt; p.life-=dt; }
    particles=particles.filter(p=>p.life>0);

    // ベスト更新
    if(score>best){ best=score; localStorage.setItem(BEST_KEY,String(best)); elBest.textContent='BEST '+best; }
  }

  // 描画：自機
  ctx.save(); ctx.shadowColor='#60a5fa'; ctx.shadowBlur=12; ctx.fillStyle='#93c5fd'; ctx.beginPath(); ctx.moveTo(player.x, player.y - player.r); ctx.lineTo(player.x - player.r*0.8, player.y + player.r*0.9); ctx.lineTo(player.x + player.r*0.8, player.y + player.r*0.9); ctx.closePath(); ctx.fill(); ctx.shadowBlur=0; ctx.restore();

  // 弾
  ctx.fillStyle='#60a5fa'; for(const b of bullets){ if(b.v!=null){ ctx.fillRect(b.x-2,b.y-10,4,10);} else { ctx.fillRect(b.x-2,b.y-6,4,6);} }

  // 敵
  for(const e of enemies){ ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fillStyle='#a78bfa'; ctx.fill(); }

  // パーティクル
  for(const p of particles){ ctx.globalAlpha=Math.max(0,p.life/0.5); ctx.fillStyle=p.color; ctx.fillRect(p.x-2,p.y-2,4,4); ctx.globalAlpha=1; }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

btnReset.addEventListener('click',()=>{ score=0; level=1; elScore.textContent='SCORE 0'; elLevel.textContent='LV 1'; bullets.length=0; enemies.length=0; particles.length=0; player.x=state.w/2; player.y=state.h*0.78; });

// ===== 最小テスト (?test=1 で実行) =====
(function(){ const q=new URLSearchParams(location.search); if(q.get('test')!=='1') return; function ok(c,m){ (c?console.log:console.error)((c?'PASS: ':'FAIL: ')+m);} // 角度→速さの符号
  bullets.length=0; const y=player.y-20; const baseV=-440; const sp=460; const shot=(x,a=0)=>{ if(a===0){ bullets.push({x,y,v:baseV}); } else { const dirX=Math.sin(a), dirY=-Math.cos(a); bullets.push({x,y,vx:dirX*sp,vy:dirY*sp}); } }; shot(player.x,0.25); ok(bullets[0].vx>0 && bullets[0].vy<0,'angle + -> right-up'); bullets.length=0; shot(player.x,-0.25); ok(bullets[0].vx<0 && bullets[0].vy<0,'angle - -> left-up'); })();
```

  </script>
</body>
</html>
